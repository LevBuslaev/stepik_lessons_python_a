for a in range(1, 151):
    for b in range(a, 151):
        for c in range(b, 151):
            for d in range(c, 151):
                for e in range(d, 151):
                    if a ** 5 + b ** 5 + c ** 5 + d ** 5 == e ** 5:
                        print(a + b + c + d + e)
#                       print('a =',a, 'b =',b, 'c =',c, 'd =',d, 'e =',e)
#========================== ЛОГИКА РЕШЕНИЯ ====================================
'''Используя лишь то, что было пройдено на этом курсе, сделал прогу, которая находит ответ за 52 сек., 
при этом просчитывает 12 145 231 операций. Вначале получалось сделать минимум с 448 875 000 операциями, 
но на это ушло бы в 40 раза больше времени, а т.е. больше получаса.

Суть вот в чём: в теории a, b, c, d могут быть одинаковыми, но также они могут быть и разными, а это значит, 
что их можно просто расположить в порядке увеличения: a - самое маленькое число из всех, d - самое больше. 
Число e вообще больше, чем любое другое, это просто очевидно, ведь a, b, c, d именно положительные, а не неотрицательные. 
Если, допустим, a == e, то a + b + c + d != e.

Начинаем с помощью for перебор для а от 1 до 150 (включительно), потом для b, но диапазон будет (a, 151), 
ведь а - самое маленькое число, как писал выше, и b не может быть меньше а, но может быть равным ему. 
Короче, вот такая иеррархия: a <= b <= c <= d < e. Далее по аналогии: range(b, 151) и range(c, 151).

Чем больше будет a, тем быстрее будут производиться рассчёты, т.к. всё лишнее будет отпадать.'''

#========================= ЕЩЁ ОДНА ЛОГИКА РЕШЕНИЯ ============================
'''Ребят, не надо каждый цикл перебирать с 1 по 150. Первый, где ищем "a", мы да, перебираем от 1 до 150.

Но второй цикл, где мы перебираем "b", нам не надо с 1 начинать перебор. Там надо установить range(a, 151), 
потому что от перемены слагаемых сумма не меняется и незачем проверять то, что уже проверено.

Аналогично в цикле, в котором перебираем "c", мы установим range(b, 151). И так далее, вплоть до цикла:

for e in range(d, 151)

Тогда уйма лишней работы отсекается.

А еще в цикле с перебором "e" можно делать проверку, как только

e**5 > a**5 + b**5 + c**5 + d**5 делать break, потому что нет дальше смысла увеличивать "e"'''
#============================================ КОНЕЦ ==============================